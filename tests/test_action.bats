#!/usr/bin/env bats

setup() {
  REPO_ROOT="$(cd "$(dirname "$BATS_TEST_FILENAME")/.." && pwd)"
  WORKDIR="$REPO_ROOT/tmp-tests"
  mkdir -p "$WORKDIR"
  cd "$WORKDIR"
}

teardown() {
  rm -rf "$WORKDIR"
}

@test "action runs successfully with no secrets" {
  # Create a repo with no secrets
  mkdir safe-repo && cd safe-repo
  git init -q
  git config user.email 'test@example.com'
  git config user.name 'test'
  echo 'hello world' > safe.txt
  git add safe.txt
  git commit -m 'safe commit'

  # Run the action locally
  cd "$REPO_ROOT"
  run act --job test-action --eventpath <(echo '{}')

  # The job should succeed
  [ "$status" -eq 0 ]

  # The output file generated by act (step outputs) should contain "secrets-leaked=0"
  grep -q "secrets-leaked=0" "$HOME/.act/secrets" || \
    grep -q "secrets-leaked=0" "$ACT_LOG_FILE"
}

@test "action detects secrets in history" {
  # Create a repo with a fake secret
  mkdir leak-repo && cd leak-repo
  git init -q
  git config user.email 'test@example.com'
  git config user.name 'test'
  echo 'password=supersecret' > creds.txt
  git add creds.txt
  git commit -m 'add secret'

  # Run the action locally
  cd "$REPO_ROOT"
  run act --job test-action --eventpath <(echo '{}')

  # The job should fail due to secret detection
  [ "$status" -ne 0 ]

  # Expect the action to report secrets-leaked > 0
  grep -Eq "secrets-leaked=[1-9][0-9]*" "$HOME/.act/secrets" || \
    grep -Eq "secrets-leaked=[1-9][0-9]*" "$ACT_LOG_FILE"
}
